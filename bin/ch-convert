#!/bin/sh

## preamble ##################################################################

lib=$(cd "$(dirname "$0")" && pwd)/../lib/charliecloud
. "${lib}/base.sh"
PATH=${ch_bin}:$PATH

# shellcheck disable=SC2034
usage=$(cat <<EOF
Convert an image from one format to another.

Usage:

  $ $(basename "$0") [-i FMT] [-o FMT] [OPTION ...] IN OUT
EOF
)


## conversion functions ######################################################

# These twenty functions (many are short) are dispatched based on function
# name at the end of the script. All take two parameters: $1 is the input
# descriptor and $2 is the output descriptor.

cv_chimage_dir () {
    chimage_in_validate "$1"
    dir_out_validate "$2"
    INFO "copying ..."
    cp -a "$img" "$2"  # FIXME: no progress meter
    dir_fixup "$2"
}

cv_dir_chimage () {
    dir_in_validate "$1"
    chimage_out_validate "$2"
    INFO "importing ..."
    ch-image import "$1" "$2"  # FIXME: no progress meter
}


## supporting functions ######################################################

# Validate that $1 can be used as an input ch-image image.
chimage_in_validate () {
    img=$(ch-image storage-path)/img/$(tag_to_path "$1")
    [ -d "$img" ] || FATAL "source image not found in ch-image storage: $1"
}

# Validate that $1 can be used as an output ch-image image.
chimage_out_validate () {
    img=$(ch-image storage-path)/img/$(tag_to_path "$1")
    if [ -d "$img" ] && [ -n "$no_clobber" ]; then
        FATAL "exists in ch-image storage, not deleting per --no-clobber: ${1}"
    fi
}

# Return basename of $2 (format $1) with no extension and filesystem-invalid
# characters removed, i.e., suitable for a new extension to be appended. Only
# extensions valid for the format $1 are considered.
desc_base () {
    fmt=$1
    dsc=$2
    case $fmt in
        dir)
            echo "$(basename "$dsc")"
            ;;
        ch-image|docker)
            echo "$(tag_to_path $dsc)"
            ;;
        squash)
            echo "$(basename "$dsc")" \
                 | sed -E 's/\.(sqfs|squash|squashfs|squishy)$//'
            ;;
        tar)
            echo "$(basename "$dsc")" | sed -E 's/\.(t.z|tar(\.(.|..))?)$//'
            ;;
        *)
            FATAL "invalid format: $fmt"
            ;;
    esac
}

# Ensure $1 has everything needed to be an image directory.
dir_fixup () {
    DEBUG "fixing up: $1"
    # Ensure mount points that ch-run needs exist. Do nothing if something
    # already exists, without dereferencing, in case it's a symlink, which
    # will work for bind-mount later but won't resolve correctly now outside
    # the container (e.g. linuxcontainers.org images; issue #1015).
    #
    # WARNING: Keep in sync with other shell scripts & Image.unpack_init().
    echo 'This directory is a Charliecloud image.' > "${1}/WEIRD_AL_YANKOVIC"
    for i in bin dev etc mnt proc usr \
             mnt/0 mnt/1 mnt/2 mnt/3 mnt/4 mnt/5 mnt/6 mnt/7 mnt/8 mnt/9; do
        exist_p "${1}/${i}" || mkdir "${1}/${i}"
    done
    for i in etc/hosts etc/resolv.conf; do
        exist_p "${1}/${i}" || touch "${1}/${i}"
    done
}

# Validate that $1 can be used as an input directory.
dir_in_validate () {
    [ -d "$1" ] || FATAL "not a directory: ${1}"
}

# Validate that $1 can be used as output directory: (1) Parent exists. (2) $1
# does not exist, unless it looks like an image, in which case remove it (or
# error if --noclobber).
dir_out_validate () {
    parent_validate "$1"
    if [ -e "$1" ]; then
        [ -d "$1" ] || FATAL "exists but not a directory: ${1}"
        if [ -d "${1}/bin" ] && [ -d "${1}/dev" ] && [ -d "${1}/usr" ]; then
            if [ -n "$no_clobber" ]; then
                FATAL "exists, not deleting per --no-clobber: ${1}"
            else
                INFO "deleting existing image: ${1}"
                rm -Rf --one-file-system "$1"
            fi
        else
            FATAL "exists but does not appear to be an image: ${1}"
        fi
    fi
}

# Return validated format $1: if non-empty and valid, return it; if empty,
# infer format from the descriptor $2; otherwise, exit with error.
fmt_validate () {
    fmt=$1
    dsc=$2
    if [ -z "$fmt" ]; then
        case $dsc in
            *.sqfs|*.squash|*.squashfs|*.squishy)
                fmt=squash
                ;;
            *.tar|*.t?z|*.tar.?|*.tar.??)
                fmt=tar
                ;;
            /*|./*)
                fmt=dir
                ;;
            *:*)
                if [ -n "$have_ch_image" ]; then
                    fmt=ch-image
                elif [ -n "$have_docker" ]; then
                    fmt=docker
                else
                    FATAL "descriptor looks like builder storage but no builder found: ${dsc}"
                fi
                ;;
            *)
                FATAL "no format given, can't infer from: ${dsc}"
                ;;
        esac
    fi
    case $fmt in
        ch-image)
            if [ -z "$have_ch_image" ]; then
                FATAL "format ch-image invalid: ch-image not found"
            fi
            ;;
        docker)
            if [ -z "$have_docker" ]; then
                FATAL "format docker invalid: docker not found"
            fi
            ;;
        dir|squash|tar)
            ;;
        *)
            FATAL "invalid format: ${fmt}"
            ;;
    esac
    echo "$fmt"
}

# Infer output descriptor by setting $out_desc, if appropriate. Otherwise,
# leave it unchanged.
out_infer () {
    if [ -n "$out_fmt_explicit" ] && [ -d "$out_desc" ]; then
        base=$(desc_base "$in_fmt" "$in_desc")
        case $out_fmt in
            dir)
                out_desc=${out_desc}/${base}
                ;;
            squash)
                if [ "$USER" = rgoff ]; then
                    out_desc=${out_desc}/${base}.squishy
                else
                    out_desc=${out_desc}/${base}.sqfs
                fi
                ;;
            tar)
                out_desc=${out_desc}/${base}.tar.gz
                ;;
        esac
    fi
}

# Validate the parent or enclosing directory of $1 exists.
parent_validate () {
    parent=$(dirname "$1")
    [ -d "$parent" ] || "not a directory: $parent"
}

tmpdir_validate () {
    case $tmpdir in
        /*)
            ;;
        *)
            FATAL "temp dir must be absolute: ${tmpdir}"
            ;;
    esac
}


## main ######################################################################

if [ -n "$TMPDIR" ]; then
    tmpdir=$TMPDIR
else
    tmpdir=/var/tmp
fi

while true; do
    if ! parse_basic_arg "$1"; then
        case $1 in
            -i|--in-fmt)
                shift
                in_fmt=$1
                ;;
            -i=*|--in-fmt=*)
                in_fmt=${1#*=}
                ;;
            -n|--dry-run)
                dry_run=yes
                ;;
            --no-clobber)
                no_clobber=yes
                ;;
            -o|--out-fmt)
                shift
                out_fmt=$1
                ;;
            -o=*|--out-fmt=*)
                out_fmt=${1#*=}
                ;;
            --tmp)
                shift
                tmpdir=$1
                ;;
            *)
                break
                ;;
        esac
    fi
    shift
done
if [ "$#" -ne 2 ]; then
    usage
fi
in_desc=$1
out_desc=$2
VERBOSE "verbose level: ${verbose}"

if command -v ch-image > /dev/null 2>&1; then
    have_ch_image=yes
    VERBOSE 'ch-image: found'
else
    VERBOSE 'ch-image: not found'
fi
if command -v docker > /dev/null 2>&1; then
    have_docker=yes
    VERBOSE 'docker: found'
else
    VERBOSE 'docker: not found'
fi

[ -n "$in_fmt" ] && in_fmt_explicit=yes
in_fmt=$(fmt_validate "$in_fmt" "$in_desc")
[ -n "$out_fmt" ] && out_fmt_explicit=yes
out_fmt=$(fmt_validate "$out_fmt" "$out_desc")
out_infer
tmpdir_validate

VERBOSE "temp dir: ${tmpdir}"
VERBOSE "noclobber: ${no_clobber:-will clobber}"
INFO 'input:   %-8s  %s' "$in_fmt"  "$in_desc"
INFO 'output:  %-8s  %s' "$out_fmt" "$out_desc"

if [ "$in_fmt" = "$out_fmt" ]; then
    FATAL 'input and output formats must be different'
fi

# POSIX sh does not support hyphen in function names, so remove it.
in_fmt_dispatch=$(echo "$in_fmt" | tr -d '-')
out_fmt_dispatch=$(echo "$out_fmt" | tr -d '-')

# Dispatch to conversion function.
"cv_${in_fmt_dispatch}_${out_fmt_dispatch}" "$in_desc" "$out_desc"
