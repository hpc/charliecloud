<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2. Tutorial &mdash; Charliecloud 0.35 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. ch-checkns" href="ch-checkns.html" />
    <link rel="prev" title="1. Installing" href="install.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Charliecloud
            <img src="_static/logo-sidebar.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.35
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">1. Installing</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#seconds-to-charliecloud">2.1. 90 seconds to Charliecloud</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#using-a-squashfs-image">2.1.1. Using a SquashFS image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-a-directory-image">2.1.2. Using a directory image</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#getting-help">2.2. Getting help</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pull-an-image">2.3. Pull an image</a></li>
<li class="toctree-l2"><a class="reference internal" href="#containers-are-not-special">2.4. Containers are not special</a></li>
<li class="toctree-l2"><a class="reference internal" href="#build-from-dockerfile">2.5. Build from Dockerfile</a></li>
<li class="toctree-l2"><a class="reference internal" href="#push-an-image">2.6. Push an image</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#destination-setup">2.6.1. Destination setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#push">2.6.2. Push</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pull-and-compare">2.6.3. Pull and compare</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mpi-hello-world">2.7. MPI Hello World</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#build-base-images">2.7.1. Build base images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#build-image">2.7.2. Build image</a></li>
<li class="toctree-l3"><a class="reference internal" href="#run-the-container">2.7.3. Run the container</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#build-cache">2.8. Build cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="#appendices">2.9. Appendices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#namespaces-with-unshare-1">2.9.1. Namespaces with <code class="code docutils literal notranslate"><span class="pre">unshare(1)</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#identifying-the-current-namespaces">2.9.1.1. Identifying the current namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-user-namespace">2.9.1.2. The user namespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-mount-namespace">2.9.1.3. The mount namespace</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#namespaces-in-charliecloud">2.9.2. Namespaces in Charliecloud</a></li>
<li class="toctree-l3"><a class="reference internal" href="#all-you-need-is-bash">2.9.3. All you need is Bash</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interacting-with-the-host">2.9.4. Interacting with the host</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#filesystems">2.9.4.1. Filesystems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#network">2.9.4.2. Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#user-and-group-ids">2.9.4.3. User and group IDs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#apache-spark">2.9.5. Apache Spark</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#interactive">2.9.5.1. Interactive</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-interactive">2.9.5.2. Non-interactive</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch-checkns.html">3. <code class="code docutils literal notranslate"><span class="pre">ch-checkns</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ch-convert.html">4. <code class="code docutils literal notranslate"><span class="pre">ch-convert</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ch-fromhost.html">5. <code class="code docutils literal notranslate"><span class="pre">ch-fromhost</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ch-image.html">6. <code class="code docutils literal notranslate"><span class="pre">ch-image</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ch-run.html">7. <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ch-run-oci.html">8. <code class="code docutils literal notranslate"><span class="pre">ch-run-oci</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="ch-test.html">9. <code class="code docutils literal notranslate"><span class="pre">ch-test</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">10. Frequently asked questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="best_practices.html">11. Best practices</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev.html">12. Contributor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Charliecloud</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">2. </span>Tutorial</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial">
<h1><span class="section-number">2. </span>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will teach you how to create and run Charliecloud images, using
both examples included with the source code as well as new ones you create
from scratch.</p>
<p>This tutorial assumes that: (a) Charliecloud is in your path, including
Charliecloud’s fully unprivileged image builder <code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> and
(b) Charliecloud is installed under <code class="code docutils literal notranslate"><span class="pre">/usr/local</span></code>. (If the second
assumption isn’t true, you will just need to modify some paths.)</p>
<p>If you want to use Docker to build images, see the <a class="reference internal" href="faq.html#faq-building-with-docker"><span class="std std-ref">FAQ</span></a>.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#seconds-to-charliecloud" id="id1">90 seconds to Charliecloud</a></p>
<ul>
<li><p><a class="reference internal" href="#using-a-squashfs-image" id="id2">Using a SquashFS image</a></p></li>
<li><p><a class="reference internal" href="#using-a-directory-image" id="id3">Using a directory image</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#getting-help" id="id4">Getting help</a></p></li>
<li><p><a class="reference internal" href="#pull-an-image" id="id5">Pull an image</a></p></li>
<li><p><a class="reference internal" href="#containers-are-not-special" id="id6">Containers are not special</a></p></li>
<li><p><a class="reference internal" href="#build-from-dockerfile" id="id7">Build from Dockerfile</a></p></li>
<li><p><a class="reference internal" href="#push-an-image" id="id8">Push an image</a></p>
<ul>
<li><p><a class="reference internal" href="#destination-setup" id="id9">Destination setup</a></p></li>
<li><p><a class="reference internal" href="#push" id="id10">Push</a></p></li>
<li><p><a class="reference internal" href="#pull-and-compare" id="id11">Pull and compare</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#mpi-hello-world" id="id12">MPI Hello World</a></p>
<ul>
<li><p><a class="reference internal" href="#build-base-images" id="id13">Build base images</a></p></li>
<li><p><a class="reference internal" href="#build-image" id="id14">Build image</a></p></li>
<li><p><a class="reference internal" href="#run-the-container" id="id15">Run the container</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#build-cache" id="id16">Build cache</a></p></li>
<li><p><a class="reference internal" href="#appendices" id="id17">Appendices</a></p>
<ul>
<li><p><a class="reference internal" href="#namespaces-with-unshare-1" id="id18">Namespaces with <code class="code docutils literal notranslate"><span class="pre">unshare(1)</span></code></a></p></li>
<li><p><a class="reference internal" href="#namespaces-in-charliecloud" id="id19">Namespaces in Charliecloud</a></p></li>
<li><p><a class="reference internal" href="#all-you-need-is-bash" id="id20">All you need is Bash</a></p></li>
<li><p><a class="reference internal" href="#interacting-with-the-host" id="id21">Interacting with the host</a></p></li>
<li><p><a class="reference internal" href="#apache-spark" id="id22">Apache Spark</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Shell sessions throughout this documentation will use the prompt <code class="code docutils literal notranslate"><span class="pre">$</span></code>
to indicate commands executed natively on the host and <code class="code docutils literal notranslate"><span class="pre">&gt;</span></code> for
commands executed in a container.</p>
</div>
<section id="seconds-to-charliecloud">
<h2><a class="toc-backref" href="#id1"><span class="section-number">2.1. </span>90 seconds to Charliecloud</a><a class="headerlink" href="#seconds-to-charliecloud" title="Permalink to this headline">¶</a></h2>
<p>This section is for the impatient. It shows you how to quickly build and run a
“hello world” Charliecloud container. If you like what you see, then proceed
with the rest of the tutorial to understand what is happening and how to use
Charliecloud for your own applications.</p>
<section id="using-a-squashfs-image">
<h3><a class="toc-backref" href="#id2"><span class="section-number">2.1.1. </span>Using a SquashFS image</a><a class="headerlink" href="#using-a-squashfs-image" title="Permalink to this headline">¶</a></h3>
<p>The preferred workflow uses our internal SquashFS mounting code. Your sysadmin
should be able to tell you if this is linked in.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> /usr/local/share/doc/charliecloud/examples/hello
<span class="gp">$</span> ch-image build .
<span class="go">inferred image name: hello</span>
<span class="go">[...]</span>
<span class="go">grown in 3 instructions: hello</span>
<span class="gp">$</span> ch-convert hello /var/tmp/hello.sqfs
<span class="go">input:   ch-image  hello</span>
<span class="go">output:  squash    /var/tmp/hello.sqfs</span>
<span class="go">packing ...</span>
<span class="go">Parallel mksquashfs: Using 8 processors</span>
<span class="go">Creating 4.0 filesystem on /var/tmp/hello.sqfs, block size 65536.</span>
<span class="go">[=============================================|] 10411/10411 100%</span>
<span class="go">[...]</span>
<span class="go">done</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- <span class="nb">echo</span> <span class="s2">&quot;I’m in a container&quot;</span>
<span class="go">I’m in a container</span>
</pre></div>
</div>
</section>
<section id="using-a-directory-image">
<h3><a class="toc-backref" href="#id3"><span class="section-number">2.1.2. </span>Using a directory image</a><a class="headerlink" href="#using-a-directory-image" title="Permalink to this headline">¶</a></h3>
<p>If not, you can create image in plain directory format instead. Most of this
tutorial uses SquashFS images, but you can adapt it analogously to this
section.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> /usr/local/share/doc/charliecloud/examples/hello
<span class="gp">$</span> ch-image build .
<span class="go">inferred image name: hello</span>
<span class="go">[...]</span>
<span class="go">grown in 4 instructions: hello</span>
<span class="gp">$</span> ch-convert hello /var/tmp/hello
<span class="go">input:   ch-image  hello</span>
<span class="go">output:  dir       /var/tmp/hello</span>
<span class="go">exporting ...</span>
<span class="go">done</span>
<span class="gp">$</span> ch-run /var/tmp/hello -- <span class="nb">echo</span> <span class="s2">&quot;I’m in a container&quot;</span>
<span class="go">I’m in a container</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can run perfectly well out of <code class="code docutils literal notranslate"><span class="pre">/tmp</span></code>, but because it is
bind-mounted automatically, the image root will then appear in multiple
locations in the container’s filesystem tree. This can cause confusion for
both users and programs.</p>
</div>
</section>
</section>
<section id="getting-help">
<h2><a class="toc-backref" href="#id4"><span class="section-number">2.2. </span>Getting help</a><a class="headerlink" href="#getting-help" title="Permalink to this headline">¶</a></h2>
<p>All the executables have decent help and can tell you what version of
Charliecloud you have (if not, please report a bug). For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run --help
<span class="go">Usage: ch-run [OPTION...] NEWROOT CMD [ARG...]</span>

<span class="go">Run a command in a Charliecloud container.</span>
<span class="go">[...]</span>
<span class="gp">$</span> ch-run --version
<span class="go">0.26</span>
</pre></div>
</div>
<p>Man pages for all commands are provided in this documentation (see table of
contents at left) as well as via <code class="code docutils literal notranslate"><span class="pre">man(1)</span></code>.</p>
</section>
<section id="pull-an-image">
<h2><a class="toc-backref" href="#id5"><span class="section-number">2.3. </span>Pull an image</a><a class="headerlink" href="#pull-an-image" title="Permalink to this headline">¶</a></h2>
<p>To start, let’s obtain a container image that someone else has already built.
The containery way to do this is the pull operation, which means to move an
image from a remote repository into local storage of some kind.</p>
<p>First, browse the Docker Hub repository of <a class="reference external" href="https://hub.docker.com/_/almalinux">official AlmaLinux images</a>. Note the list of tags; this is a
partial list of image versions that are available. We’ll use the tag
“<code class="code docutils literal notranslate"><span class="pre">8</span></code>”.</p>
<p>Use the Charliecloud program <code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> to pull this image to
Charliecloud’s internal storage directory:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image pull almalinux:8
<span class="go">pulling image:    almalinux:8</span>
<span class="go">requesting arch:  amd64</span>
<span class="go">manifest list: downloading: 100%</span>
<span class="go">manifest: downloading: 100%</span>
<span class="go">config: downloading: 100%</span>
<span class="go">layer 1/1: 3239c63: downloading: 68.2/68.2 MiB (100%)</span>
<span class="go">pulled image: adding to build cache</span>
<span class="go">flattening image</span>
<span class="go">layer 1/1: 3239c63: listing</span>
<span class="go">validating tarball members</span>
<span class="go">layer 1/1: 3239c63: changed 42 absolute symbolic and/or hard links to relative</span>
<span class="go">resolving whiteouts</span>
<span class="go">layer 1/1: 3239c63: extracting</span>
<span class="go">image arch: amd64</span>
<span class="go">done</span>
<span class="gp">$</span> ch-image list
<span class="go">almalinux:8</span>
</pre></div>
</div>
<p>Images come in lots of different formats; <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> can use directories
and SquashFS archives. For this example, we’ll use SquashFS. We use the
command <code class="code docutils literal notranslate"><span class="pre">ch-convert</span></code> to create a SquashFS image from the image in
internal storage, then run it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-convert almalinux:8 almalinux.sqfs
<span class="gp">$</span> ch-run almalinux.sqfs -- /bin/bash
<span class="gp">&gt;</span> <span class="nb">pwd</span>
<span class="go">/</span>
<span class="gp">&gt;</span> ls
<span class="go">bin  ch  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run</span>
<span class="go">sbin  srv  sys  tmp  usr  var</span>
<span class="gp">&gt;</span> cat /etc/redhat-release
<span class="go">AlmaLinux release 8.7 (Stone Smilodon)</span>
<span class="gp">&gt;</span> <span class="nb">exit</span>
</pre></div>
</div>
<p>What do these commands do?</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Create a SquashFS-format image (<code class="code docutils literal notranslate"><span class="pre">ch-convert</span> <span class="pre">...</span></code>).</p></li>
<li><p>Create a running container using that image (<code class="code docutils literal notranslate"><span class="pre">ch-run</span>
<span class="pre">almalinux.sqfs</span></code>).</p></li>
<li><p>Stop processing <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> options (<code class="code docutils literal notranslate"><span class="pre">--</span></code>). (This is
standard notation for UNIX command line programs.)</p></li>
<li><p>Run the program <code class="code docutils literal notranslate"><span class="pre">/bin/bash</span></code> inside the container, which starts an
interactive shell, where we enter a few commands and then exit, returning
to the host.</p></li>
</ol>
</div></blockquote>
</section>
<section id="containers-are-not-special">
<h2><a class="toc-backref" href="#id6"><span class="section-number">2.4. </span>Containers are not special</a><a class="headerlink" href="#containers-are-not-special" title="Permalink to this headline">¶</a></h2>
<p>Many folks would like you to believe that containers are magic and special
(especially if they want to sell you their container product). This is not the
case. To demonstrate, we’ll create a working container image using standard
UNIX tools.</p>
<p>Many Linux distributions provide tarballs containing installed base images,
including Alpine. We can use these in Charliecloud directly:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> wget -O alpine.tar.gz <span class="s1">&#39;https://github.com/alpinelinux/docker-alpine/blob/v3.16/x86_64/alpine-minirootfs-3.16.3-x86_64.tar.gz?raw=true&#39;</span>
<span class="gp">$</span> tar tf alpine.tar.gz <span class="p">|</span> head -10
<span class="go">./</span>
<span class="go">./root/</span>
<span class="go">./var/</span>
<span class="go">./var/log/</span>
<span class="go">./var/lock/</span>
<span class="go">./var/lock/subsys/</span>
<span class="go">./var/spool/</span>
<span class="go">./var/spool/cron/</span>
<span class="go">./var/spool/cron/crontabs</span>
<span class="go">./var/spool/mail</span>
</pre></div>
</div>
<p>This tarball is what’s called a “tarbomb”, so we need to provide an enclosing
directory to avoid making a mess:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir alpine
<span class="gp">$</span> <span class="nb">cd</span> alpine
<span class="gp">$</span> tar xf ../alpine.tar.gz
<span class="gp">$</span> ls
<span class="go">bin  etc   lib    mnt  proc  run   srv  tmp  var</span>
<span class="go">dev  home  media  opt  root  sbin  sys  usr</span>
<span class="gp">$</span> du -sh
<span class="go">5.6M  .</span>
<span class="gp">$</span> <span class="nb">cd</span> ..
</pre></div>
</div>
<p>Now, run a shell in the container! (Note that base Alpine does not have Bash,
so we run <code class="code docutils literal notranslate"><span class="pre">/bin/sh</span></code> instead.)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run ./alpine -- /bin/sh
<span class="gp">&gt;</span> <span class="nb">pwd</span>
<span class="go">/</span>
<span class="gp">&gt;</span> ls
<span class="go">bin    etc    lib    mnt    proc   run    srv    tmp    var</span>
<span class="go">dev    home   media  opt    root   sbin   sys    usr</span>
<span class="gp">&gt;</span> cat /etc/alpine-release
<span class="go">3.16.3</span>
<span class="gp">&gt;</span> <span class="nb">exit</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Generally, you should avoid directory-format images on shared filesystems
such as NFS and Lustre, in favor of local storage such as <code class="code docutils literal notranslate"><span class="pre">tmpfs</span></code> and
local hard disks. This will yield better performance for you and anyone
else on the shared filesystem. In contrast, SquashFS images should work
fine on shared filesystems.</p>
</div>
</section>
<section id="build-from-dockerfile">
<h2><a class="toc-backref" href="#id7"><span class="section-number">2.5. </span>Build from Dockerfile</a><a class="headerlink" href="#build-from-dockerfile" title="Permalink to this headline">¶</a></h2>
<p>The other containery way to get an image is the build operation. This
interprets a recipe, usually a Dockerfile, to create an image and place it
into builder storage. We can then extract the image from builder storage to a
directory and run it.</p>
<p>Charliecloud supports arbitrary image builders. In this tutorial, we use
<code class="code docutils literal notranslate"><span class="pre">ch-image</span></code>, which comes with Charliecloud, but you can also use others,
e.g. Docker or Podman. <code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> is a big deal because it is completely
unprivileged. Other builders typically run as root or require setuid root
helper programs; this raises a number of security questions.</p>
<p>We’ll write a “Hello World” Python program and put it into an image we specify
with a Dockerfile. Set up a directory to work in:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir hello.src
<span class="gp">$</span> <span class="nb">cd</span> hello.src
</pre></div>
</div>
<p>Type in the following program as <code class="code docutils literal notranslate"><span class="pre">hello.py</span></code> using your least favorite
editor:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/python3</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hello World!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, create a file called <code class="code docutils literal notranslate"><span class="pre">Dockerfile</span></code> and type in the following
recipe:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">almalinux:8</span>
<span class="k">RUN</span> yum -y install python36
<span class="k">COPY</span> ./hello.py /
<span class="k">RUN</span> chmod <span class="m">755</span> /hello.py
</pre></div>
</div>
<p>These four instructions say:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">FROM</span></code>: We are extending the <code class="code docutils literal notranslate"><span class="pre">almalinux:8</span></code> <em>base image</em>.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">RUN</span></code>: Install the <code class="code docutils literal notranslate"><span class="pre">python36</span></code> RPM package, which we need for
our Hello World program.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">COPY</span></code>: Copy the file <code class="code docutils literal notranslate"><span class="pre">hello.py</span></code> we just made to the root
directory of the image. In the source argument, the path is relative to
the <em>context directory</em>, which we’ll see more of below.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">RUN</span></code>: Make that file executable.</p></li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="code docutils literal notranslate"><span class="pre">COPY</span></code> is a standard instruction but has a number of disadvantages in
its corner cases. Charliecloud also has <code class="code docutils literal notranslate"><span class="pre">RSYNC</span></code>, which addresses
these; see <a class="reference internal" href="ch-image.html#ch-image-rsync"><span class="std std-ref">its documentation</span></a> for details.</p>
</div>
<p>Let’s build this image:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build -t hello -f Dockerfile .
<span class="go">  1. FROM almalinux:8</span>
<span class="go">[...]</span>
<span class="go">  4. RUN chmod 755 /hello.py</span>
<span class="go">grown in 4 instructions: hello</span>
</pre></div>
</div>
<p>This command says:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Build (<code class="code docutils literal notranslate"><span class="pre">ch-image</span> <span class="pre">build</span></code>) an image named (a.k.a. tagged) “hello”
(<code class="code docutils literal notranslate"><span class="pre">-t</span> <span class="pre">hello</span></code>).</p></li>
<li><p>Use the Dockerfile called “Dockerfile” (<code class="code docutils literal notranslate"><span class="pre">-f</span> <span class="pre">Dockerfile</span></code>).</p></li>
<li><p>Use the current directory as the context directory (<code class="code docutils literal notranslate"><span class="pre">.</span></code>).</p></li>
</ol>
</div></blockquote>
<p>Now, list the images <code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> knows about:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image list
<span class="go">almalinux:8</span>
<span class="go">hello</span>
</pre></div>
</div>
<p>And run the image we just made:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">cd</span> ..
<span class="gp">$</span> ch-convert hello hello.sqfs
<span class="gp">$</span> ch-run hello.sqfs -- /hello.py
<span class="go">Hello World!</span>
</pre></div>
</div>
<p>This time, we’ve run our application directly rather than starting an
interactive shell.</p>
</section>
<section id="push-an-image">
<h2><a class="toc-backref" href="#id8"><span class="section-number">2.6. </span>Push an image</a><a class="headerlink" href="#push-an-image" title="Permalink to this headline">¶</a></h2>
<p>The containery way to share your images is by pushing them to a container
registry. In this section, we will set up a registry on GitLab and push the
hello image to that registry, then pull it back to compare.</p>
<section id="destination-setup">
<h3><a class="toc-backref" href="#id9"><span class="section-number">2.6.1. </span>Destination setup</a><a class="headerlink" href="#destination-setup" title="Permalink to this headline">¶</a></h3>
<p>Create a private container registry:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Browse to <a class="reference external" href="https://gitlab.com">https://gitlab.com</a> (or any other GitLab instance).</p></li>
<li><p>Log in. You should end up on your <em>Projects</em> page.</p></li>
<li><p>Click <em>New project</em> then <em>Create blank project</em>.</p></li>
<li><p>Name your project “<code class="code docutils literal notranslate"><span class="pre">test-registry</span></code>”. Leave <em>Visibility Level</em> at
<em>Private</em>. Click <em>Create project</em>. You should end up at your project’s
main page.</p></li>
<li><p>At left, choose <em>Settings</em> (the gear icon) → <em>General</em>, then <em>Visibility,
project features, permissions</em>. Enable <em>Container registry</em>, then click
<em>Save changes</em>.</p></li>
<li><p>At left, choose Packages &amp; Registries (the box icon) → Container
registry. You should see the message “There are no container images
stored for this project”.</p></li>
</ol>
</div></blockquote>
<p>At this point, we have a container registry set up, and we need to teach
<code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> how to log into it. On <code class="code docutils literal notranslate"><span class="pre">gitlab.com</span></code> and some other
instances, you can use your GitLab password. However, GitLab has a thing
called a <em>personal access token</em> (PAT) that can be used no matter how you log
into the GitLab web app. To create one:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Click on your avatar at the top right. Choose <em>Edit Profile</em>.</p></li>
<li><p>At left, choose <em>Access Tokens</em> (the three-pin plug icon).</p></li>
<li><p>Type in the name “<code class="code docutils literal notranslate"><span class="pre">registry</span></code>”. Tick the boxes <em>read_registry</em> and
<em>write_registry</em>. Click <em>Create personal access token</em>.</p></li>
<li><p>Your PAT will be displayed at the top of the result page under <em>Your new
personal access token</em>. Copy this string and store it somewhere safe &amp;
policy-compliant for your organization. (Also, you can revoke it at the
end of the tutorial if you like.)</p></li>
</ol>
</div></blockquote>
</section>
<section id="push">
<h3><a class="toc-backref" href="#id10"><span class="section-number">2.6.2. </span>Push</a><a class="headerlink" href="#push" title="Permalink to this headline">¶</a></h3>
<p>We can now use <code class="code docutils literal notranslate"><span class="pre">ch-image</span> <span class="pre">push</span></code> to push the image to GitLab. (Note that
the tagging step you would need for Docker is unnecessary here, because we can
just specify a destination reference at push time.)</p>
<p>You will need to substitute your GitLab username for <code class="code docutils literal notranslate"><span class="pre">$USER</span></code> below.</p>
<p>When you are prompted for credentials, enter your GitLab username and
copy-paste the PAT you created earlier (or enter your password).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The specific GitLab path may vary depending on how your GitLab is set up.
Check the Docker examples on the empty container registry page for the
value you need. For example, if you put your container registry in a group
called “containers”, the image reference would be
<code class="code docutils literal notranslate"><span class="pre">gitlab.com/$USER/containers/myproj/hello:latest</span></code>.</p>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image push hello gitlab.com:5050/<span class="nv">$USER</span>/myproj/hello:latest
<span class="go">pushing image:   hello</span>
<span class="go">destination:     gitlab.com:5050/$USER/myproj/hello:latest</span>
<span class="go">layer 1/1: gathering</span>
<span class="go">layer 1/1: preparing</span>
<span class="go">preparing metadata</span>
<span class="go">starting upload</span>
<span class="go">layer 1/1: bca515d: checking if already in repository</span>

<span class="go">Username: $USER</span>
<span class="go">Password:</span>
<span class="go">layer 1/1: bca515d: not present, uploading: 139.8/139.8 MiB(100%</span>
<span class="go">config: f969909: checking if already in repository</span>
<span class="go">config: f969909: not present, uploading</span>
<span class="go">manifest: uploading</span>
<span class="go">cleaning up</span>
<span class="go">done</span>
</pre></div>
</div>
<p>Go back to your container registry page. You should see your image listed now!</p>
</section>
<section id="pull-and-compare">
<h3><a class="toc-backref" href="#id11"><span class="section-number">2.6.3. </span>Pull and compare</a><a class="headerlink" href="#pull-and-compare" title="Permalink to this headline">¶</a></h3>
<p>Let’s pull that image and see how it looks:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image pull --auth registry.gitlab.com/<span class="nv">$USER</span>/myproj/hello:latest hello.2
<span class="go">pulling image:   gitlab.com:5050/$USER/myproj/hello:latest</span>
<span class="go">destination:     hello.2</span>
<span class="go">[...]</span>
<span class="gp">$</span> ch-image list
<span class="go">almalinux:8</span>
<span class="go">hello</span>
<span class="go">hello.2</span>
<span class="gp">$</span> ch-convert hello.2 ./hello.2
<span class="gp">$</span> ls ./hello.2
<span class="go">bin    etc    lib    mnt    proc   run    srv    tmp    var</span>
<span class="go">dev    home   media  opt    root   sbin   sys    usr</span>
</pre></div>
</div>
</section>
</section>
<section id="mpi-hello-world">
<h2><a class="toc-backref" href="#id12"><span class="section-number">2.7. </span>MPI Hello World</a><a class="headerlink" href="#mpi-hello-world" title="Permalink to this headline">¶</a></h2>
<p>In this section, we’ll build and run a simple MPI parallel program.</p>
<p>Image builds can be chained. Here, we’ll build a chain of four images: the
official <code class="code docutils literal notranslate"><span class="pre">almalinux:8</span></code> image, a customized AlmaLinux 8 image, an OpenMPI
image, and finally the application image.</p>
<p>Important: Many of the specifics in this section will vary from site to site.
In that case, follow your site’s instructions instead.</p>
<section id="build-base-images">
<h3><a class="toc-backref" href="#id13"><span class="section-number">2.7.1. </span>Build base images</a><a class="headerlink" href="#build-base-images" title="Permalink to this headline">¶</a></h3>
<p>First, build two images using the Dockerfiles provided with Charliecloud.
These two build should take about 15 minutes total, depending on the speed of
your system.</p>
<p>Note that Charliecloud infers their names from the Dockerfile name, so we
don’t need to specify <code class="code docutils literal notranslate"><span class="pre">-t</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build <span class="se">\</span>
     -f /usr/local/share/doc/charliecloud/examples/Dockerfile.almalinux_8ch <span class="se">\</span>
     /usr/local/share/doc/charliecloud/examples
<span class="gp">$</span> ch-image build <span class="se">\</span>
     -f /usr/local/share/doc/charliecloud/examples/Dockerfile.openmpi <span class="se">\</span>
        /usr/local/share/doc/charliecloud/examples
</pre></div>
</div>
</section>
<section id="build-image">
<h3><a class="toc-backref" href="#id14"><span class="section-number">2.7.2. </span>Build image</a><a class="headerlink" href="#build-image" title="Permalink to this headline">¶</a></h3>
<p>Next, create a new directory for this project, and within it the following
simple C program called <code class="code docutils literal notranslate"><span class="pre">mpihello.c</span></code>. (Note the program contains a bug;
consider fixing it.)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">#</span>include &lt;stdio.h&gt;
<span class="gp">#</span>include &lt;mpi.h&gt;

<span class="go">int main (int argc, char **argv)</span>
<span class="go">{</span>
<span class="go">   int msg, rank, rank_ct;</span>

<span class="go">   MPI_Init(&amp;argc, &amp;argv);</span>
<span class="go">   MPI_Comm_size(MPI_COMM_WORLD, &amp;rank_ct);</span>
<span class="go">   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span>

<span class="go">   printf(&quot;hello from rank %d of %d\n&quot;, rank, rank_ct);</span>

<span class="go">   if (rank == 0) {</span>
<span class="go">      for (int i = 1; i &lt; rank_ct; i++) {</span>
<span class="go">         MPI_Send(&amp;msg, 1, MPI_INT, i, 0, MPI_COMM_WORLD);</span>
<span class="go">         printf(&quot;rank %d sent %d to rank %d\n&quot;, rank, msg, i);</span>
<span class="go">      }</span>
<span class="go">   } else {</span>
<span class="go">      MPI_Recv(&amp;msg, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span>
<span class="go">      printf(&quot;rank %d received %d from rank 0\n&quot;, rank, msg);</span>
<span class="go">   }</span>

<span class="go">   MPI_Finalize();</span>
<span class="go">}</span>
</pre></div>
</div>
<p>Add this <code class="code docutils literal notranslate"><span class="pre">Dockerfile</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">FROM openmpi</span>
<span class="go">RUN mkdir /hello</span>
<span class="go">WORKDIR /hello</span>
<span class="go">COPY mpihello.c .</span>
<span class="go">RUN mpicc -o mpihello mpihello.c .</span>
</pre></div>
</div>
<p>(The instruction <code class="code docutils literal notranslate"><span class="pre">WORKDIR</span></code> changes directories; the default working
directory within a Dockerfile is <code class="code docutils literal notranslate"><span class="pre">/</span></code>).</p>
<p>Now build. The default Dockerfile is <code class="code docutils literal notranslate"><span class="pre">./Dockerfile</span></code>, so we can omit
<code class="code docutils literal notranslate"><span class="pre">-f</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls
<span class="go">Dockerfile   mpihello.c</span>
<span class="gp">$</span> ch-image build -t mpihello
<span class="gp">$</span> ch-image list
<span class="go">almalinux:8</span>
<span class="go">almalinux_8ch</span>
<span class="go">mpihello</span>
<span class="go">openmpi</span>
</pre></div>
</div>
<p>Finally, create a squashball image and copy it to the supercomputer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-convert mpihello mpihello.sqfs
<span class="gp">$</span> scp mpihello.sqfs super-fe:
</pre></div>
</div>
</section>
<section id="run-the-container">
<h3><a class="toc-backref" href="#id15"><span class="section-number">2.7.3. </span>Run the container</a><a class="headerlink" href="#run-the-container" title="Permalink to this headline">¶</a></h3>
<p>We’ll run this application interactively. One could also put similar steps in
a Slurm batch script.</p>
<p>First, obtain a two-node allocation and load Charliecloud:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> salloc -N2 -t <span class="m">1</span>:00:00
<span class="go">salloc: Granted job allocation 599518</span>
<span class="go">[...]</span>
<span class="gp">$</span> module load charliecloud
</pre></div>
</div>
<p>Then, run the application on all cores in your allocation:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> srun -c1 ch-run ~/mpihello.sqfs -- /hello/mpihello
<span class="go">hello from rank 1 of 72</span>
<span class="go">rank 1 received 0 from rank 0</span>
<span class="go">[...]</span>
<span class="go">hello from rank 63 of 72</span>
<span class="go">rank 63 received 0 from rank 0</span>
</pre></div>
</div>
<p>Win!</p>
</section>
</section>
<section id="build-cache">
<h2><a class="toc-backref" href="#id16"><span class="section-number">2.8. </span>Build cache</a><a class="headerlink" href="#build-cache" title="Permalink to this headline">¶</a></h2>
<p><code class="code docutils literal notranslate"><span class="pre">ch-image</span></code> subcommands that create images, such as build and pull, can
use a build cache to speed repeated operations. That is, an image is created
by starting from the empty image and executing a sequence of instructions,
largely Dockerfile instructions but also some others like “pull” and “import”.
Some instructions are expensive to execute so it’s often cheaper to retrieve
their results from cache instead.</p>
<p>Let’s set up this example by first resetting the build cache:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build-cache --reset
<span class="gp">$</span> mkdir cache-test
<span class="gp">$</span> <span class="nb">cd</span> cache-test
</pre></div>
</div>
<p>Suppose we have a Dockerfile <code class="code docutils literal notranslate"><span class="pre">a.df</span></code>:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">almalinux:8</span>
<span class="k">RUN</span> sleep <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> foo
<span class="k">RUN</span> sleep <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> bar
</pre></div>
</div>
<p>On our first build, we get:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build -t a -f a.df .
<span class="go">  1. FROM almalinux:8</span>
<span class="go">[ ... pull chatter omitted ... ]</span>
<span class="go">  2. RUN echo foo</span>
<span class="go">copying image ...</span>
<span class="go">foo</span>
<span class="go">  3. RUN echo bar</span>
<span class="go">bar</span>
<span class="go">grown in 3 instructions: a</span>
</pre></div>
</div>
<p>Note the dot after each instruction’s line number. This means that the
instruction was executed. You can also see this in the output of the two
<code class="code docutils literal notranslate"><span class="pre">echo</span></code> commands.</p>
<p>But on our second build, we get:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build -t a -f a.df .
<span class="go">  1* FROM almalinux:8</span>
<span class="go">  2* RUN sleep 2 &amp;&amp; echo foo</span>
<span class="go">  3* RUN sleep 2 &amp;&amp; echo bar</span>
<span class="go">copying image ...</span>
<span class="go">grown in 3 instructions: a</span>
</pre></div>
</div>
<p>Here, instead of being executed, each instruction’s results were retrieved
from cache. Cache hit for each instruction is indicted by an asterisk
(“<code class="code docutils literal notranslate"><span class="pre">*</span></code>”) after the line number. Even for such a small and short
Dockerfile, this build is noticeably faster than the first.</p>
<p>Let’s also try a second, slightly different Dockerfile, <code class="code docutils literal notranslate"><span class="pre">b.df</span></code>. The
first two instructions are the same, but the third is different.</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">almalinux:8</span>
<span class="k">RUN</span> sleep <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> foo
<span class="k">RUN</span> sleep <span class="m">2</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> qux
</pre></div>
</div>
<p>Build it:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build -t b -f b.df .
<span class="go">  1* FROM almalinux:8</span>
<span class="go">  2* RUN sleep 2 &amp;&amp; echo foo</span>
<span class="go">  3. RUN sleep 2 &amp;&amp; echo qux</span>
<span class="go">copying image</span>
<span class="go">qux</span>
<span class="go">grown in 3 instructions: b</span>
</pre></div>
</div>
<p>Here, the first two instructions are hits from the first Dockerfile, but the
third is a miss, so Charliecloud retrieves that state and continues building.</p>
<p>Finally, inspect the cache:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-image build-cache --tree
<span class="go">*  (b) RUN sleep 2 &amp;&amp; echo qux</span>
<span class="go">| *  (a) RUN sleep 2 &amp;&amp; echo bar</span>
<span class="go">|/</span>
<span class="go">*  RUN sleep 2 &amp;&amp; echo foo</span>
<span class="go">*  (almalinux:8) PULL almalinux:8</span>
<span class="go">*  (root) ROOT</span>

<span class="go">named images:    4</span>
<span class="go">state IDs:       5</span>
<span class="go">commits:         5</span>
<span class="go">files:         317</span>
<span class="go">disk used:       3 MiB</span>
</pre></div>
</div>
<p>Here there are four named images: <code class="code docutils literal notranslate"><span class="pre">a</span></code> and <code class="code docutils literal notranslate"><span class="pre">b</span></code> that we built, the
base image <code class="code docutils literal notranslate"><span class="pre">almalinux:8</span></code>, and the empty base of everything <code class="code docutils literal notranslate"><span class="pre">ROOT</span></code>.
Also note that <code class="code docutils literal notranslate"><span class="pre">a</span></code> and <code class="code docutils literal notranslate"><span class="pre">b</span></code> diverge after the last common
instruction <code class="code docutils literal notranslate"><span class="pre">RUN</span> <span class="pre">sleep</span> <span class="pre">2</span> <span class="pre">&amp;&amp;</span> <span class="pre">echo</span> <span class="pre">foo</span></code>.</p>
</section>
<section id="appendices">
<h2><a class="toc-backref" href="#id17"><span class="section-number">2.9. </span>Appendices</a><a class="headerlink" href="#appendices" title="Permalink to this headline">¶</a></h2>
<p>These appendices contain further tutorials that may be enlightening but are
less essential to understanding Charliecloud.</p>
<section id="namespaces-with-unshare-1">
<h3><a class="toc-backref" href="#id18"><span class="section-number">2.9.1. </span>Namespaces with <code class="code docutils literal notranslate"><span class="pre">unshare(1)</span></code></a><a class="headerlink" href="#namespaces-with-unshare-1" title="Permalink to this headline">¶</a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">unshare(1)</span></code> is a shell command that comes with most new-ish Linux
distributions in the <code class="code docutils literal notranslate"><span class="pre">util-linux</span></code> package. We will use it to explore a
little about how namespaces, which are the basis of containers, work.</p>
<section id="identifying-the-current-namespaces">
<h4><span class="section-number">2.9.1.1. </span>Identifying the current namespaces<a class="headerlink" href="#identifying-the-current-namespaces" title="Permalink to this headline">¶</a></h4>
<p>There are several kinds of namespaces, and every process is always in one
namespace of each kind. Namespaces within each kind form a tree. Every
namespace has an ID number, which you can see in <code class="code docutils literal notranslate"><span class="pre">/proc</span></code> with some magic
symlinks:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /proc/self/ns
<span class="go">total 0</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 cgroup -&gt; &#39;cgroup:[4026531835]&#39;</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 ipc -&gt; &#39;ipc:[4026531839]&#39;</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 mnt -&gt; &#39;mnt:[4026531840]&#39;</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 net -&gt; &#39;net:[4026531992]&#39;</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 pid -&gt; &#39;pid:[4026531836]&#39;</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 pid_for_children -&gt; &#39;pid:[4026531836]&#39;</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 user -&gt; &#39;user:[4026531837]&#39;</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Mar 31 16:44 uts -&gt; &#39;uts:[4026531838]&#39;</span>
</pre></div>
</div>
<p>Let’s start a new shell with different user and mount namespaces. Note how the
ID numbers change for these two, but not the others.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> unshare --user --mount
<span class="gp">&gt;</span> ls -l /proc/self/ns <span class="p">|</span> tee inside.txt
<span class="go">total 0</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 cgroup -&gt; &#39;cgroup:[4026531835]&#39;</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 ipc -&gt; &#39;ipc:[4026531839]&#39;</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 mnt -&gt; &#39;mnt:[4026532733]&#39;</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 net -&gt; &#39;net:[4026531992]&#39;</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 pid -&gt; &#39;pid:[4026531836]&#39;</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 pid_for_children -&gt; &#39;pid:[4026531836]&#39;</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 user -&gt; &#39;user:[4026532732]&#39;</span>
<span class="go">lrwxrwxrwx 1 nobody nogroup 0 Mar 31 16:46 uts -&gt; &#39;uts:[4026531838]&#39;</span>
<span class="gp">&gt;</span> <span class="nb">exit</span>
</pre></div>
</div>
<p>These IDs are available both in the name and inode number of the magic symlink
target:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> stat -L /proc/self/ns/user
<span class="go">  File: /proc/self/ns/user</span>
<span class="go">  Size: 0            Blocks: 0          IO Block: 4096   regular empty file</span>
<span class="go">Device: 4h/4d        Inode: 4026531837  Links: 1</span>
<span class="go">Access: (0444/-r--r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span>
<span class="go">Access: 2022-12-16 10:56:54.916459868 -0700</span>
<span class="go">Modify: 2022-12-16 10:56:54.916459868 -0700</span>
<span class="go">Change: 2022-12-16 10:56:54.916459868 -0700</span>
<span class="go"> Birth: -</span>
<span class="gp">$</span> unshare --user --mount -- stat -L /proc/self/ns/user
<span class="go">  File: /proc/self/ns/user</span>
<span class="go">  Size: 0            Blocks: 0          IO Block: 4096   regular empty file</span>
<span class="go">Device: 4h/4d        Inode: 4026532565  Links: 1</span>
<span class="go">Access: (0444/-r--r--r--)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)</span>
<span class="go">Access: 2022-12-16 10:57:07.136561077 -0700</span>
<span class="go">Modify: 2022-12-16 10:57:07.136561077 -0700</span>
<span class="go">Change: 2022-12-16 10:57:07.136561077 -0700</span>
<span class="go"> Birth: -</span>
</pre></div>
</div>
</section>
<section id="the-user-namespace">
<h4><span class="section-number">2.9.1.2. </span>The user namespace<a class="headerlink" href="#the-user-namespace" title="Permalink to this headline">¶</a></h4>
<p>Unprivileged user namespaces let you map your effective user id (UID) to any
UID inside the namespace, and your effective group ID (GID) to any GID. Let’s
try it. First, who are we?</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> id
<span class="go">uid=1000(charlie) gid=1000(charlie)</span>
<span class="go">groups=1000(charlie),24(cdrom),25(floppy),27(sudo),29(audio)</span>
</pre></div>
</div>
<p>This shows our user (1000 <code class="code docutils literal notranslate"><span class="pre">charlie</span></code>), our primary group (1000
<code class="code docutils literal notranslate"><span class="pre">charlie</span></code>), and a bunch of supplementary groups.</p>
<p>Let’s start a user namespace, mapping our UID to 0 (<code class="code docutils literal notranslate"><span class="pre">root</span></code>) and our GID
to 0 (<code class="code docutils literal notranslate"><span class="pre">root</span></code>):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> unshare --user --map-root-user
<span class="gp">&gt;</span> id
<span class="go">uid=0(root) gid=0(root) groups=0(root),65534(nogroup)</span>
</pre></div>
</div>
<p>This shows that our UID inside the container is 0, our GID is 0, and all
supplementary groups have collapsed into 65534:code:<cite>nogroup</cite>, because they
are unmapped inside the namespace. (If <code class="code docutils literal notranslate"><span class="pre">id</span></code> complains about not finding
names for IDs, just ignore it.)</p>
<p>We are root!! Let’s try something sneaky!!!</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;</span> cat /etc/shadow
<span class="go">cat: /etc/shadow: Permission denied</span>
</pre></div>
</div>
<p>Drat! The kernel followed the UID map outside the namespace and used that for
access control; i.e., we are still acting as us, a normal unprivileged user
who cannot read <code class="code docutils literal notranslate"><span class="pre">/etc/shadow</span></code>. Something else interesting:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;</span> ls -l /etc/shadow
<span class="go">-rw-r----- 1 nobody nogroup 2151 Feb 10 11:51 /etc/shadow</span>
<span class="gp">&gt;</span> <span class="nb">exit</span>
</pre></div>
</div>
<p>This shows up as <code class="code docutils literal notranslate"><span class="pre">nobody:nogroup</span></code> because UID 0 and GID 0 outside the
container are not mapped to anything inside (i.e., they are <em>unmapped</em>).</p>
</section>
<section id="the-mount-namespace">
<h4><span class="section-number">2.9.1.3. </span>The mount namespace<a class="headerlink" href="#the-mount-namespace" title="Permalink to this headline">¶</a></h4>
<p>This namespace lets us set up an independent filesystem tree. For this
exercise, you will need two terminals.</p>
<p>In Terminal 1, set up namespaces and mount a new tmpfs over your home
directory:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> unshare --mount --user
<span class="gp">&gt;</span> mount -t tmpfs none /home/charlie
<span class="go">mount: only root can use &quot;--types&quot; option</span>
</pre></div>
</div>
<p>Wait! What!? The problem now is that you still need to be root inside the
container to use the <code class="code docutils literal notranslate"><span class="pre">mount(2)</span></code> system call. Try again:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> unshare --mount --user --map-root-user
<span class="gp">&gt;</span> mount -t tmpfs none /home/charlie
<span class="gp">&gt;</span> mount <span class="p">|</span> fgrep /home/charlie
<span class="go">none on /home/charlie type tmpfs (rw,relatime,uid=1000,gid=1000)</span>
<span class="gp">&gt;</span> touch /home/charlie/foo
<span class="gp">&gt;</span> ls /home/charlie
<span class="go">foo</span>
</pre></div>
</div>
<p>In Terminal 2, which is not in the container, note how the mount doesn’t show
up in <code class="code docutils literal notranslate"><span class="pre">mount</span></code> output and the files you created are not present:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls /home/charlie
<span class="go">articles.txt             flu-index.tsv           perms_test</span>
<span class="go">[...]</span>
<span class="gp">$</span> mount <span class="p">|</span> fgrep /home/charlie
<span class="gp">$</span>
</pre></div>
</div>
<p>Exit the container in Terminal 1:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;</span> <span class="nb">exit</span>
</pre></div>
</div>
</section>
</section>
<section id="namespaces-in-charliecloud">
<h3><a class="toc-backref" href="#id19"><span class="section-number">2.9.2. </span>Namespaces in Charliecloud</a><a class="headerlink" href="#namespaces-in-charliecloud" title="Permalink to this headline">¶</a></h3>
<p>Let’s revisit the symlinks in <code class="code docutils literal notranslate"><span class="pre">/proc</span></code>, but this time with Charliecloud:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /proc/self/ns
<span class="go">total 0</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 11:24 ipc -&gt; ipc:[4026531839]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 11:24 mnt -&gt; mnt:[4026531840]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 11:24 net -&gt; net:[4026531969]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 11:24 pid -&gt; pid:[4026531836]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 11:24 user -&gt; user:[4026531837]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 11:24 uts -&gt; uts:[4026531838]</span>
<span class="gp">$</span> ch-run /var/tmp/hello -- ls -l /proc/self/ns
<span class="go">total 0</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 17:34 ipc -&gt; ipc:[4026531839]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 17:34 mnt -&gt; mnt:[4026532257]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 17:34 net -&gt; net:[4026531969]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 17:34 pid -&gt; pid:[4026531836]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 17:34 user -&gt; user:[4026532256]</span>
<span class="go">lrwxrwxrwx 1 charlie charlie 0 Sep 28 17:34 uts -&gt; uts:[4026531838]</span>
</pre></div>
</div>
<p>The container has different mount (<code class="code docutils literal notranslate"><span class="pre">mnt</span></code>) and user (<code class="code docutils literal notranslate"><span class="pre">user</span></code>)
namespaces, but the rest of the namespaces are shared with the host. This
highlights Charliecloud’s focus on functionality (make your container run),
rather than isolation (protect the host from your container).</p>
<p>Normally, each invocation of <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> creates a new container, so if you
have multiple simultaneous invocations, they will not share containers. In
some cases this can cause problems with MPI programs. However, there is an
option <code class="code docutils literal notranslate"><span class="pre">--join</span></code> that can solve them; see the <a class="reference internal" href="faq.html#faq-join"><span class="std std-ref">FAQ</span></a> for
details.</p>
</section>
<section id="all-you-need-is-bash">
<h3><a class="toc-backref" href="#id20"><span class="section-number">2.9.3. </span>All you need is Bash</a><a class="headerlink" href="#all-you-need-is-bash" title="Permalink to this headline">¶</a></h3>
<p>In this exercise, we’ll use shell commands to create minimal container image
with a working copy of Bash, and that’s all. To do so, we need to set up a
directory with the Bash binary, the shared libraries it uses, and a few other
hooks needed by Charliecloud.</p>
<p><strong>Important:</strong> Your Bash is almost certainly linked differently than described
below. Use the paths from your terminal, not this tutorial. Adjust the steps
below as needed. It will not work otherwise.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ldd /bin/bash
<span class="go">    linux-vdso.so.1 (0x00007ffdafff2000)</span>
<span class="go">    libtinfo.so.6 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f6935cb6000)</span>
<span class="go">    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f6935cb1000)</span>
<span class="go">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6935af0000)</span>
<span class="go">    /lib64/ld-linux-x86-64.so.2 (0x00007f6935e21000)</span>
<span class="gp">$</span> ls -l /lib/x86_64-linux-gnu/libc.so.6
<span class="go">lrwxrwxrwx 1 root root 12 May  1  2019 /lib/x86_64-linux-gnu/libc.so.6 -&gt; libc-2.28.so</span>
</pre></div>
</div>
<p>The shared libraries pointed to are symlinks, so we’ll use <code class="code docutils literal notranslate"><span class="pre">cp</span> <span class="pre">-L</span></code> to
dereference them and copy the target files. <code class="code docutils literal notranslate"><span class="pre">linux-vdso.so.1</span></code> is a
kernel thing, not a shared library file, so we don’t copy that.</p>
<p>Set up the container:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir alluneed
<span class="gp">$</span> <span class="nb">cd</span> alluneed
<span class="gp">$</span> mkdir bin
<span class="gp">$</span> mkdir dev
<span class="gp">$</span> mkdir lib
<span class="gp">$</span> mkdir lib64
<span class="gp">$</span> mkdir lib/x86_64-linux-gnu
<span class="gp">$</span> mkdir proc
<span class="gp">$</span> mkdir sys
<span class="gp">$</span> mkdir tmp
<span class="gp">$</span> cp -pL /bin/bash ./bin
<span class="gp">$</span> cp -pL /lib/x86_64-linux-gnu/libtinfo.so.6 ./lib/x86_64-linux-gnu
<span class="gp">$</span> cp -pL /lib/x86_64-linux-gnu/libdl.so.2 ./lib/x86_64-linux-gnu
<span class="gp">$</span> cp -pL /lib/x86_64-linux-gnu/libc.so.6 ./lib/x86_64-linux-gnu
<span class="gp">$</span> cp -pL /lib64/ld-linux-x86-64.so.2 ./lib64/ld-linux-x86-64.so.2
<span class="gp">$</span> <span class="nb">cd</span> ..
<span class="gp">$</span> ls -lR alluneed
<span class="go">./alluneed:</span>
<span class="go">total 0</span>
<span class="go">drwxr-x--- 2 charlie charlie 60 Mar 31 17:15 bin</span>
<span class="go">drwxr-x--- 2 charlie charlie 40 Mar 31 17:26 dev</span>
<span class="go">drwxr-x--- 2 charlie charlie 80 Mar 31 17:27 etc</span>
<span class="go">drwxr-x--- 3 charlie charlie 60 Mar 31 17:17 lib</span>
<span class="go">drwxr-x--- 2 charlie charlie 60 Mar 31 17:19 lib64</span>
<span class="go">drwxr-x--- 2 charlie charlie 40 Mar 31 17:26 proc</span>
<span class="go">drwxr-x--- 2 charlie charlie 40 Mar 31 17:26 sys</span>
<span class="go">drwxr-x--- 2 charlie charlie 40 Mar 31 17:27 tmp</span>

<span class="go">./alluneed/bin:</span>
<span class="go">total 1144</span>
<span class="go">-rwxr-xr-x 1 charlie charlie 1168776 Apr 17  2019 bash</span>

<span class="go">./alluneed/dev:</span>
<span class="go">total 0</span>

<span class="go">./alluneed/lib:</span>
<span class="go">total 0</span>
<span class="go">drwxr-x--- 2 charlie charlie 100 Mar 31 17:19 x86_64-linux-gnu</span>

<span class="go">./alluneed/lib/x86_64-linux-gnu:</span>
<span class="go">total 1980</span>
<span class="go">-rwxr-xr-x 1 charlie charlie 1824496 May  1  2019 libc.so.6</span>
<span class="go">-rw-r--r-- 1 charlie charlie   14592 May  1  2019 libdl.so.2</span>
<span class="go">-rw-r--r-- 1 charlie charlie  183528 Nov  2 12:16 libtinfo.so.6</span>

<span class="go">./alluneed/lib64:</span>
<span class="go">total 164</span>
<span class="go">-rwxr-xr-x 1 charlie charlie 165632 May  1  2019 ld-linux-x86-64.so.2</span>

<span class="go">./alluneed/proc:</span>
<span class="go">total 0</span>

<span class="go">./alluneed/sys:</span>
<span class="go">total 0</span>

<span class="go">./alluneed/tmp:</span>
<span class="go">total 0</span>
</pre></div>
</div>
<p>Next, start a container and run <code class="code docutils literal notranslate"><span class="pre">/bin/bash</span></code> within it. Option
<code class="code docutils literal notranslate"><span class="pre">--no-passwd</span></code> turns off some convenience features that this image isn’t
prepared for.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run --no-passwd ./alluneed -- /bin/bash
<span class="gp">&gt;</span> <span class="nb">pwd</span>
<span class="go">/</span>
<span class="gp">&gt;</span> <span class="nb">echo</span> <span class="s2">&quot;hello world&quot;</span>
<span class="go">hello world</span>
<span class="gp">&gt;</span> ls /
<span class="go">bash: ls: command not found</span>
<span class="gp">&gt;</span> <span class="nb">echo</span> *
<span class="go">bin dev home lib lib64 proc sys tmp</span>
<span class="gp">&gt;</span> <span class="nb">exit</span>
</pre></div>
</div>
<p>It’s not very useful since the only commands we have are Bash built-ins, but
it’s a container!</p>
</section>
<section id="interacting-with-the-host">
<h3><a class="toc-backref" href="#id21"><span class="section-number">2.9.4. </span>Interacting with the host</a><a class="headerlink" href="#interacting-with-the-host" title="Permalink to this headline">¶</a></h3>
<p>Charliecloud is not an isolation layer, so containers have full access to host
resources, with a few quirks. This section demonstrates how that works.</p>
<section id="filesystems">
<h4><span class="section-number">2.9.4.1. </span>Filesystems<a class="headerlink" href="#filesystems" title="Permalink to this headline">¶</a></h4>
<p>Charliecloud makes host directories available inside the container using bind
mounts, which is somewhat like a hard link in that it causes a file or
directory to appear in multiple places in the filesystem tree, but it is a
property of the running kernel rather than the filesystem.</p>
<p>Several host directories are always bind-mounted into the container. These</p>
<p>include system directories such as <code class="code docutils literal notranslate"><span class="pre">/dev</span></code>, <code class="code docutils literal notranslate"><span class="pre">/proc</span></code>, <code class="code docutils literal notranslate"><span class="pre">/sys</span></code>,
and <code class="code docutils literal notranslate"><span class="pre">/tmp</span></code>. Others can be requested with a command line option, e.g.
<code class="code docutils literal notranslate"><span class="pre">--home</span></code> bind-mounts the invoking user’s home directory.</p>
<p>Charliecloud uses recursive bind mounts, so for example if the host has a
variety of sub-filesystems under <code class="code docutils literal notranslate"><span class="pre">/sys</span></code>, as Ubuntu does, these will be
available in the container as well.</p>
<p>In addition to these, arbitrary user-specified directories can be added using
the <code class="code docutils literal notranslate"><span class="pre">--bind</span></code> or <code class="code docutils literal notranslate"><span class="pre">-b</span></code> switch. By default, mounts use the same path
as provided from the host. In the case of directory images, which are
writeable, the target mount directory will be automatically created before the
container is started:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir /var/tmp/foo0
<span class="gp">$</span> <span class="nb">echo</span> hello &gt; /var/tmp/foo0/bar
<span class="gp">$</span> mkdir /var/tmp/foo1
<span class="gp">$</span> <span class="nb">echo</span> world &gt; /var/tmp/foo1/bar
<span class="gp">$</span> ch-run -b /var/tmp/foo0 -b /var/tmp/foo1 /var/tmp/hello -- bash
<span class="gp">&gt;</span> cat /var/tmp/foo0/bar
<span class="go">hello</span>
<span class="gp">&gt;</span> cat /var/tmp/foo1/bar
<span class="go">world</span>
</pre></div>
</div>
<p>However, as SquashFS filesystems are read-only, in this case you must provide
a destination that already exists, like those created under <code class="code docutils literal notranslate"><span class="pre">/mnt</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir /var/tmp/foo0
<span class="gp">$</span> <span class="nb">echo</span> hello &gt; /var/tmp/foo0/bar
<span class="gp">$</span> mkdir /var/tmp/foo1
<span class="gp">$</span> <span class="nb">echo</span> world &gt; /var/tmp/foo1/bar
<span class="gp">$</span> ch-run -b /var/tmp/foo0 -b /var/tmp/foo1 /var/tmp/hello -- bash
<span class="go">ch-run[1184427]: error: can’t mkdir: /var/tmp/hello/var/tmp/foo0: Read-only file system (ch_misc.c:142 30)</span>
<span class="gp">$</span> ch-run -b /var/tmp/foo0:/mnt/0 -b /var/tmp/foo1:/mnt/1 /var/tmp/hello -- bash
<span class="gp">&gt;</span> ls /mnt
<span class="go">0  1  2  3  4  5  6  7  8  9</span>
<span class="gp">&gt;</span> cat /mnt/0/bar
<span class="go">hello</span>
<span class="gp">&gt;</span> cat /mnt/1/bar
<span class="go">world</span>
</pre></div>
</div>
</section>
<section id="network">
<h4><span class="section-number">2.9.4.2. </span>Network<a class="headerlink" href="#network" title="Permalink to this headline">¶</a></h4>
<p>Charliecloud containers share the host’s network namespace, so most network
things should be the same.</p>
<p>However, SSH is not aware of Charliecloud containers. If you SSH to a node
where Charliecloud is installed, you will get a shell on the host, not in a
container, even if <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> was initiated from a container:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
<span class="gp">$</span> ssh localhost stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- /bin/bash
<span class="gp">&gt;</span> stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
<span class="gp">&gt;</span> ssh localhost stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026531837</span>
</pre></div>
</div>
<p>There are a couple ways to SSH to a remote node and run commands inside a
container. The simplest is to manually invoke <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> in the
<code class="code docutils literal notranslate"><span class="pre">ssh</span></code> command:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh localhost ch-run /var/tmp/hello.sqfs -- stat -L --format<span class="o">=</span><span class="s1">&#39;%i&#39;</span> /proc/self/ns/user
<span class="go">4026532256</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Recall that by default, each <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> invocation creates a new
container. That is, the <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> command above has not entered an
existing user namespace <code class="code docutils literal notranslate"><span class="pre">’2256</span></code>; rather, it has re-used the namespace
ID <code class="code docutils literal notranslate"><span class="pre">’2256</span></code>.</p>
</div>
<p>Another may be to edit one’s shell initialization scripts to check the command
line and <code class="code docutils literal notranslate"><span class="pre">exec(1)</span></code> <code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> if appropriate. This is brittle but
avoids wrapping <code class="code docutils literal notranslate"><span class="pre">ssh</span></code> or altering its command line.</p>
</section>
<section id="user-and-group-ids">
<h4><span class="section-number">2.9.4.3. </span>User and group IDs<a class="headerlink" href="#user-and-group-ids" title="Permalink to this headline">¶</a></h4>
<p>Unlike Docker and some other container systems, Charliecloud tries to make the
container’s users and groups look the same as the host’s. This is accomplished
by bind-mounting a custom <code class="code docutils literal notranslate"><span class="pre">/etc/passwd</span></code> and <code class="code docutils literal notranslate"><span class="pre">/etc/group</span></code> into the
container. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> id -u
<span class="go">901</span>
<span class="gp">$</span> whoami
<span class="go">charlie</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> id -u
<span class="go">901</span>
<span class="gp">&gt;</span> whoami
<span class="go">charlie</span>
</pre></div>
</div>
<p>More specifically, the user namespace, when created without privileges as
Charliecloud does, lets you map any container UID to your host UID.
<code class="code docutils literal notranslate"><span class="pre">ch-run</span></code> implements this with the <code class="code docutils literal notranslate"><span class="pre">--uid</span></code> switch. So, for example,
you can tell Charliecloud you want to be root, and it will tell you that
you’re root:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run --uid <span class="m">0</span> /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> id -u
<span class="go">0</span>
<span class="gp">&gt;</span> whoami
<span class="go">root</span>
</pre></div>
</div>
<p>But, as shown above, this doesn’t get you anything useful, because the
container UID is mapped back to your UID on the host before permission checks
are applied:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;</span> dd <span class="k">if</span><span class="o">=</span>/dev/mem <span class="nv">of</span><span class="o">=</span>/tmp/pwned
<span class="go">dd: failed to open &#39;/dev/mem&#39;: Permission denied</span>
</pre></div>
</div>
<p>This mapping also affects how users are displayed. For example, if a file is
owned by you, your host UID will be mapped to your container UID, which is
then looked up in <code class="code docutils literal notranslate"><span class="pre">/etc/passwd</span></code> to determine the display name. In
typical usage without <code class="code docutils literal notranslate"><span class="pre">--uid</span></code>, this mapping is a no-op, so everything
looks normal:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -nd ~
<span class="go">drwxr-xr-x 87 901 901 4096 Sep 28 12:12 /home/charlie</span>
<span class="gp">$</span> ls -ld ~
<span class="go">drwxr-xr-x 87 charlie charlie 4096 Sep 28 12:12 /home/charlie</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> ls -nd ~
<span class="go">drwxr-xr-x 87 901 901 4096 Sep 28 18:12 /home/charlie</span>
<span class="gp">&gt;</span> ls -ld ~
<span class="go">drwxr-xr-x 87 charlie charlie 4096 Sep 28 18:12 /home/charlie</span>
</pre></div>
</div>
<p>But if <code class="code docutils literal notranslate"><span class="pre">--uid</span></code> is provided, things can seem odd. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run --uid <span class="m">0</span> /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> ls -nd /home/charlie
<span class="go">drwxr-xr-x 87 0 901 4096 Sep 28 18:12 /home/charlie</span>
<span class="gp">&gt;</span> ls -ld /home/charlie
<span class="go">drwxr-xr-x 87 root charlie 4096 Sep 28 18:12 /home/charlie</span>
</pre></div>
</div>
<p>This UID mapping can contain only one pair: an arbitrary container UID to your
effective UID on the host. Thus, all other users are unmapped, and they show
up as <code class="code docutils literal notranslate"><span class="pre">nobody</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -n /tmp/foo
<span class="go">-rw-rw---- 1 902 902 0 Sep 28 15:40 /tmp/foo</span>
<span class="gp">$</span> ls -l /tmp/foo
<span class="go">-rw-rw---- 1 sig sig 0 Sep 28 15:40 /tmp/foo</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> ls -n /tmp/foo
<span class="go">-rw-rw---- 1 65534 65534 843 Sep 28 21:40 /tmp/foo</span>
<span class="gp">&gt;</span> ls -l /tmp/foo
<span class="go">-rw-rw---- 1 nobody nogroup 843 Sep 28 21:40 /tmp/foo</span>
</pre></div>
</div>
<p>User namespaces have a similar mapping for GIDs, with the same limitation —
exactly one arbitrary container GID maps to your effective <em>primary</em> GID. This
can lead to some strange-looking results, because only one of your GIDs can be
mapped in any given container. All the rest become <code class="code docutils literal notranslate"><span class="pre">nogroup</span></code>:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> id
<span class="go">uid=901(charlie) gid=901(charlie) groups=901(charlie),903(nerds),904(losers)</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- id
<span class="go">uid=901(charlie) gid=901(charlie) groups=901(charlie),65534(nogroup)</span>
<span class="gp">$</span> ch-run --gid <span class="m">903</span> /var/tmp/hello.sqfs -- id
<span class="go">uid=901(charlie) gid=903(nerds) groups=903(nerds),65534(nogroup)</span>
</pre></div>
</div>
<p>However, this doesn’t affect access. The container process retains the same
GIDs from the host perspective, and as always, the host IDs are what control
access:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /tmp/primary /tmp/supplemental
<span class="go">-rw-rw---- 1 sig charlie 0 Sep 28 15:47 /tmp/primary</span>
<span class="go">-rw-rw---- 1 sig nerds  0 Sep 28 15:48 /tmp/supplemental</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- bash
<span class="gp">&gt;</span> cat /tmp/primary &gt; /dev/null
<span class="gp">&gt;</span> cat /tmp/supplemental &gt; /dev/null
</pre></div>
</div>
<p>One area where functionality <em>is</em> reduced is that <code class="code docutils literal notranslate"><span class="pre">chgrp(1)</span></code> becomes
useless. Using an unmapped group or <code class="code docutils literal notranslate"><span class="pre">nogroup</span></code> fails, and using a mapped
group is a no-op because it’s mapped back to the host GID:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ls -l /tmp/bar
<span class="go">rw-rw---- 1 charlie charlie 0 Sep 28 16:12 /tmp/bar</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- chgrp nerds /tmp/bar
<span class="go">chgrp: changing group of &#39;/tmp/bar&#39;: Invalid argument</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- chgrp nogroup /tmp/bar
<span class="go">chgrp: changing group of &#39;/tmp/bar&#39;: Invalid argument</span>
<span class="gp">$</span> ch-run --gid <span class="m">903</span> /var/tmp/hello.sqfs -- chgrp nerds /tmp/bar
<span class="gp">$</span> ls -l /tmp/bar
<span class="go">-rw-rw---- 1 charlie charlie 0 Sep 28 16:12 /tmp/bar</span>
</pre></div>
</div>
<p>Workarounds include <code class="code docutils literal notranslate"><span class="pre">chgrp(1)</span></code> on the host or fastidious use of setgid
directories:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir /tmp/baz
<span class="gp">$</span> chgrp nerds /tmp/baz
<span class="gp">$</span> chmod <span class="m">2770</span> /tmp/baz
<span class="gp">$</span> ls -ld /tmp/baz
<span class="go">drwxrws--- 2 charlie nerds 40 Sep 28 16:19 /tmp/baz</span>
<span class="gp">$</span> ch-run /var/tmp/hello.sqfs -- touch /tmp/baz/foo
<span class="gp">$</span> ls -l /tmp/baz/foo
<span class="go">-rw-rw---- 1 charlie nerds 0 Sep 28 16:21 /tmp/baz/foo</span>
</pre></div>
</div>
</section>
</section>
<section id="apache-spark">
<h3><a class="toc-backref" href="#id22"><span class="section-number">2.9.5. </span>Apache Spark</a><a class="headerlink" href="#apache-spark" title="Permalink to this headline">¶</a></h3>
<p>This example is in <code class="code docutils literal notranslate"><span class="pre">examples/spark</span></code>. Build a SquashFS image of it and
upload it to your supercomputer.</p>
<section id="interactive">
<h4><span class="section-number">2.9.5.1. </span>Interactive<a class="headerlink" href="#interactive" title="Permalink to this headline">¶</a></h4>
<p>We need to first create a basic configuration for Spark, as the defaults in
the Dockerfile are insufficient. For real jobs, you’ll want to also configure
performance parameters such as memory use; see <a class="reference external" href="http://spark.apache.org/docs/latest/configuration.html">the documentation</a>. First:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> mkdir -p ~/sparkconf
<span class="gp">$</span> chmod <span class="m">700</span> ~/sparkconf
</pre></div>
</div>
<p>We’ll want to use the supercomputer’s high-speed network. For this example,
we’ll find the Spark master’s IP manually:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ip -o -f inet addr show <span class="p">|</span> cut -d/ -f1
<span class="go">1: lo    inet 127.0.0.1</span>
<span class="go">2: eth0  inet 192.168.8.3</span>
<span class="go">8: eth1  inet 10.8.8.3</span>
</pre></div>
</div>
<p>Your site support can tell you which to use. In this case, we’ll use 10.8.8.3.</p>
<p>Create some configuration files. Replace <code class="code docutils literal notranslate"><span class="pre">[MYSECRET]</span></code> with a string only
you know. Edit to match your system; in particular, use local disks instead of
<code class="code docutils literal notranslate"><span class="pre">/tmp</span></code> if you have them:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat &gt; ~/sparkconf/spark-env.sh
<span class="go">SPARK_LOCAL_DIRS=/tmp/spark</span>
<span class="go">SPARK_LOG_DIR=/tmp/spark/log</span>
<span class="go">SPARK_WORKER_DIR=/tmp/spark</span>
<span class="go">SPARK_LOCAL_IP=127.0.0.1</span>
<span class="go">SPARK_MASTER_HOST=10.8.8.3</span>
<span class="gp">$</span> cat &gt; ~/sparkconf/spark-defaults.conf
<span class="go">spark.authenticate true</span>
<span class="go">spark.authenticate.secret [MYSECRET]</span>
</pre></div>
</div>
<p>We can now start the Spark master:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- /spark/sbin/start-master.sh
</pre></div>
</div>
<p>Look at the log in <code class="code docutils literal notranslate"><span class="pre">/tmp/spark/log</span></code> to see that the master started
correctly:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail -7 /tmp/spark/log/*master*.out
<span class="go">17/02/24 22:37:21 INFO Master: Starting Spark master at spark://10.8.8.3:7077</span>
<span class="go">17/02/24 22:37:21 INFO Master: Running Spark version 2.0.2</span>
<span class="go">17/02/24 22:37:22 INFO Utils: Successfully started service &#39;MasterUI&#39; on port 8080.</span>
<span class="go">17/02/24 22:37:22 INFO MasterWebUI: Bound MasterWebUI to 127.0.0.1, and started at http://127.0.0.1:8080</span>
<span class="go">17/02/24 22:37:22 INFO Utils: Successfully started service on port 6066.</span>
<span class="go">17/02/24 22:37:22 INFO StandaloneRestServer: Started REST server for submitting applications on port 6066</span>
<span class="go">17/02/24 22:37:22 INFO Master: I have been elected leader! New state: ALIVE</span>
</pre></div>
</div>
<p>If you can run a web browser on the node, browse to
<code class="code docutils literal notranslate"><span class="pre">http://localhost:8080</span></code> for the Spark master web interface. Because this
capability varies, the tutorial does not depend on it, but it can be
informative. Refresh after each key step below.</p>
<p>The Spark workers need to know how to reach the master. This is via a URL; you
can get it from the log excerpt above, or consult the web interface. For
example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nv">MASTER_URL</span><span class="o">=</span>spark://10.8.8.3:7077
</pre></div>
</div>
<p>Next, start one worker on each compute node.</p>
<p>In this tutorial, we start the workers using <code class="code docutils literal notranslate"><span class="pre">srun</span></code> in a way that
prevents any subsequent <code class="code docutils literal notranslate"><span class="pre">srun</span></code> invocations from running until the Spark
workers exit. For our purposes here, that’s OK, but it’s a significant
limitation for some jobs. (See <a class="reference external" href="https://github.com/hpc/charliecloud/issues/230">issue #230</a>.) Alternatives include
<code class="code docutils literal notranslate"><span class="pre">pdsh</span></code>, which is the approach we use for the Spark tests
(<code class="code docutils literal notranslate"><span class="pre">examples/other/spark/test.bats</span></code>), or a simple for loop of <code class="code docutils literal notranslate"><span class="pre">ssh</span></code>
calls. Both of these are also quite clunky and do not scale well.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> srun sh -c <span class="s2">&quot;   ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- \</span>
<span class="s2">                        spark/sbin/start-slave.sh </span><span class="nv">$MASTER_URL</span><span class="s2"> \</span>
<span class="s2">              &amp;&amp; sleep infinity&quot;</span> <span class="p">&amp;</span>
</pre></div>
</div>
<p>One of the advantages of Spark is that it’s resilient: if a worker becomes
unavailable, the computation simply proceeds without it. However, this can
mask issues as well. For example, this example will run perfectly fine with
just one worker, or all four workers on the same node, which aren’t what we
want.</p>
<p>Check the master log to see that the right number of workers registered:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span>  fgrep worker /tmp/spark/log/*master*.out
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:39890 with 16 cores, 187.8 GB RAM</span>
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:44735 with 16 cores, 187.8 GB RAM</span>
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:22445 with 16 cores, 187.8 GB RAM</span>
<span class="go">17/02/24 22:52:24 INFO Master: Registering worker 127.0.0.1:29473 with 16 cores, 187.8 GB RAM</span>
</pre></div>
</div>
<p>Despite the workers calling themselves 127.0.0.1, they really are running
across the allocation. (The confusion happens because of our
<code class="code docutils literal notranslate"><span class="pre">$SPARK_LOCAL_IP</span></code> setting above.) This can be verified by examining logs
on each compute node. For example (note single quotes):</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ssh <span class="m">10</span>.8.8.4 -- tail -3 <span class="s1">&#39;/tmp/spark/log/*worker*.out&#39;</span>
<span class="go">17/02/24 22:52:24 INFO Worker: Connecting to master 10.8.8.3:7077...</span>
<span class="go">17/02/24 22:52:24 INFO TransportClientFactory: Successfully created connection to /10.8.8.3:7077 after 263 ms (216 ms spent in bootstraps)</span>
<span class="go">17/02/24 22:52:24 INFO Worker: Successfully registered with master spark://10.8.8.3:7077</span>
</pre></div>
</div>
<p>We can now start an interactive shell to do some Spark computing:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- /spark/bin/pyspark --master <span class="nv">$MASTER_URL</span>
</pre></div>
</div>
<p>Let’s use this shell to estimate 𝜋 (this is adapted from one of the Spark
<a class="reference external" href="http://spark.apache.org/examples.html">examples</a>):</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">operator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">random</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>   <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(),</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SAMPLE_CT</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">2e8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SAMPLE_CT</span><span class="p">))</span> \
<span class="gp">... </span>       <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> \
<span class="gp">... </span>       <span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.0</span><span class="o">*</span><span class="n">ct</span><span class="o">/</span><span class="n">SAMPLE_CT</span>
<span class="go">3.14109824</span>
</pre></div>
</div>
<p>(Type Control-D to exit.)</p>
<p>We can also submit jobs to the Spark cluster. This one runs the same example
as included with the Spark source code. (The voluminous logging output is
omitted.)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> ch-run -b ~/sparkconf /var/tmp/spark.sqfs -- <span class="se">\</span>
         /spark/bin/spark-submit --master <span class="nv">$MASTER_URL</span> <span class="se">\</span>
         /spark/examples/src/main/python/pi.py <span class="m">1024</span>
<span class="go">[...]</span>
<span class="go">Pi is roughly 3.141211</span>
<span class="go">[...]</span>
</pre></div>
</div>
<p>Exit your allocation. Slurm will clean up the Spark daemons.</p>
<p>Success! Next, we’ll run a similar job non-interactively.</p>
</section>
<section id="non-interactive">
<h4><span class="section-number">2.9.5.2. </span>Non-interactive<a class="headerlink" href="#non-interactive" title="Permalink to this headline">¶</a></h4>
<p>We’ll re-use much of the above to run the same computation non-interactively.
For brevity, the Slurm script at <code class="code docutils literal notranslate"><span class="pre">examples/other/spark/slurm.sh</span></code> is not
reproduced here.</p>
<p>Submit it as follows. It requires three arguments: the squashball, the image
directory to unpack into, and the high-speed network interface. Again, consult
your site administrators for the latter.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> sbatch -N4 slurm.sh spark.sqfs /var/tmp ib0
<span class="go">Submitted batch job 86754</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> fgrep <span class="s1">&#39;Pi is&#39;</span> slurm-86754.out
<span class="go">Pi is roughly 3.141393</span>
</pre></div>
</div>
<p>Success! (to four significant digits)</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="install.html" class="btn btn-neutral float-left" title="1. Installing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ch-checkns.html" class="btn btn-neutral float-right" title="3. ch-checkns" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014–2023, Triad National Security, LLC and others.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>